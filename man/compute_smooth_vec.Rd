% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/smooth.R
\name{compute_smooth_vec}
\alias{compute_smooth_vec}
\title{Smooth vectors.}
\usage{
compute_smooth_vec(x, z, span = 0.25, n_bin = 1000, n_smooth = 100,
  weight = NULL)
}
\arguments{
\item{x, z}{Numeric vectors.}

\item{span}{Fraction of data that should be used by the smoother. Will
be weighted by distance from predicted point.}

\item{n_bin, n_smooth}{Number of components to use for binning and
for smoothing.}

\item{weight}{Optional. A numeric vector giving a weight for each
location.}
}
\description{
This method is analogous to \code{\link{loess}} but it first finely bins the
data. This yields a substantially performance improvement (<1s for 10m
points), while adding on worsening performance slightly (and typically the
error will be less than 1 pixel).
}
\examples{
x <- runif(1e4, 0, 4 * pi)
y <- sin(x) + runif(1e4, -0.5, 0.5)
plot(x, y)
smu <- compute_smooth_vec(x, y, span = 0.25)
lines(smu$x, smu$y, type = "l", col = "red", lwd = 2)
x_grid <- seq(0, 4 * pi, length = 100)
lines(x_grid, sin(x_grid), type = "l", col = "blue", lwd = 2)
lines(x_grid, predict(loess(y ~ x), data.frame(x = x_grid)), col = "green", lwd = 2)
}

