% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bin-compute.R
\name{compute_bin}
\alias{compute_bin}
\title{Bin continuous data into equal sized ranges.}
\usage{
compute_bin(data, x_var, w_var = NULL, width = NULL, center = NULL,
  boundary = NULL, closed = c("right", "left"), pad = FALSE)
}
\arguments{
\item{data}{Dataset-like object to bin. Built-in methods for data frames,
grouped data frames and ggvis visualisations.}

\item{x_var, w_var}{Names of x and weight variables. The x variable must be
continuous.}

\item{width}{(Positive real). The width of a bin. For S3 objects, the
  interpretation of width depends on the interpretation
  of the underlying numeric vector. For example, for dates, 1 = 1 day;
  for times 1 = 1 second; and for difftime, the units vary.

  If \code{NULL}, the \code{width} will be derived from the data,
  picking approximately 30 bins with nice widths. You should always override
  this value, exploring multiple widths to find the best to illustrate the
  stories in your data.}

\item{center}{Set the position of the first bin by specifying
  the position of either a boundary or the center of a bin.
  For example, you can always center the bins on integers with
  \code{center = 0} regardless of where the first bin actually falls.

  Think of binning as tiling the real line into a infinite sequence of
  intervals. \code{center} and \code{boundary} set the position of
  one of those intervals.}

\item{boundary}{Set the position of the first bin by specifying
  the position of either a boundary or the center of a bin.
  For example, you can always center the bins on integers with
  \code{center = 0} regardless of where the first bin actually falls.

  Think of binning as tiling the real line into a infinite sequence of
  intervals. \code{center} and \code{boundary} set the position of
  one of those intervals.}

\item{closed}{One of \code{"right"} or \code{"left"} indicating whether the
bin interval is left-closed (i.e. [a, b)), or right-closed (i.e. (a, b]).}

\item{pad}{If \code{TRUE}, adds empty bins at either end of x. This ensures
frequency polygons touch 0 outside the range of x. Defaults to \code{FALSE}.}
}
\value{
A data frame with columns:
 \item{count_}{the number of points}
 \item{x_}{mid-point of bin}
 \item{xmin_}{left boundary of bin}
 \item{xmax_}{right boundary of bin}
}
\description{
Bin continuous data into equal sized ranges.
}
\examples{
mtcars \%>\% compute_bin(~mpg)
mtcars \%>\% compute_bin(~mpg, width = 10)
if (requireNamespace("dplyr", quietly = TRUE)) {
  mtcars \%>\% dplyr::group_by(cyl) \%>\% compute_bin(~mpg, width = 10)
}

# Missing values get own bin
mtcars2 <- mtcars
mtcars2$mpg[sample(32, 5)] <- NA
mtcars2 \%>\% compute_bin(~mpg, width = 10)
}
\seealso{
\code{\link{compute_count}} For counting cases at specific locations
}

