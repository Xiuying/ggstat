% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bin.R
\name{bin}
\alias{bin}
\alias{bin_breaks}
\alias{bin_date}
\alias{bin_fixed}
\title{Bin a continuous vector.}
\usage{
bin_fixed(x, width = NULL, center = NULL, boundary = NULL,
  origin = NULL, terminus = NULL, bins = 30, pad = FALSE,
  closed = c("right", "left"))

bin_breaks(breaks, closed = c("right", "left"))

bin_date(x, bins = 30, closed = c("right", "left"))
}
\arguments{
\item{x}{A numeric vector to guess parameters from.}

\item{width}{(Positive real). The width of a bin. For S3 objects, the
  interpretation of width depends on the interpretation
  of the underlying numeric vector. For example, for dates, 1 = 1 day;
  for times 1 = 1 second; and for difftime, the units vary.

  If \code{NULL}, the \code{width} will be derived from the data,
  picking approximately \code{bins} bins with nice widths. You should always
  override this value, exploring multiple widths to find the best to
  illustrate the stories in your data.}

\item{boundary, center}{Set the position of the first bin by specifying
  the position of either a boundary or the center of a bin.
  For example, you can always center the bins on integers with
  \code{center = 0} regardless of where the first bin actually falls.

  Think of binning as tiling the real line into a infinite sequence of
  intervals. \code{center} and \code{boundary} set the position of
  one of those intervals.}

\item{origin, terminus}{The locations of the left-most and right-most bins.
Any values outside this range will be treated as missing. You should
usually leave \code{origin} as \code{NULL} so that it is automatically
computed from \code{center} and \code{boundary}.}

\item{bins}{Number of bins to use if not specified. Pretty bin sizes are
preferred over matching this value exactly.}

\item{pad}{If \code{TRUE}, adds empty bins at either end of x. This ensures
frequency polygons touch 0 outside the range of x. Defaults to \code{FALSE}.}

\item{closed}{One of \code{"right"} or \code{"left"} indicating whether the
bin interval is left-closed (i.e. [a, b)), or right-closed (i.e. (a, b]).}

\item{breaks}{A numeric vector of break points.}
}
\description{
Bin a numeric vector and count how many observations fall in each bin.
Supports weights so that you can re-bin pre-binned data.
}
\section{Floating point}{

If a point is less than \code{binwidth} / 10^8 from the boundary between
two bins, it is shifted to fall in the bin with the closest "closed" side.
}
\examples{
x <- runif(1e6)
compute_stat(bin_fixed(x), x)
compute_stat(bin_fixed(x, width = 0.25), x)
compute_stat(bin_breaks(c(0, 0.1, 0.9, 1)), x)

# Can also create fixed bins without data, if you supply the origin
# terminus, and width
bin_fixed(origin = 0, terminus = 1, width = 0.25)

bin_fixed(x, bins = 37)

# Bin other types of object
x1 <- Sys.time() + runif(1000) * 60
compute_stat(bin_date(x1), x1)
x2 <- Sys.Date() + sample(30, 10)
compute_stat(bin_date(x2), x2)

# For fixed bin width, performance scales linearly with the size of x.
x <- runif(1e7)
system.time(compute_stat(bin_fixed(x, width = 1e-1), x))
system.time(compute_stat(bin_fixed(x, width = 1e-2), x))
system.time(compute_stat(bin_fixed(x, width = 1e-5), x))

# For arbitrary breaks, performance scales linearly with x and
# logarthmically with the number of bins.
system.time(compute_stat(bin_breaks(seq(0, 1, length = 10)), x))
system.time(compute_stat(bin_breaks(seq(0, 1, length = 100)), x))
system.time(compute_stat(bin_breaks(seq(0, 1, length = 1000)), x))
}

