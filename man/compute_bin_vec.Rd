% Generated by roxygen2 (4.0.2): do not edit by hand
\name{compute_bin_vec}
\alias{compute_bin_vec}
\title{Bin continuous vector into equal sized ranges.}
\usage{
compute_bin_vec(x, w = NULL, width = NULL, origin = NULL, center = NULL,
  boundary = NULL, closed = c("right", "left"), pad = FALSE)
}
\arguments{
\item{x}{A numeric vector to bin.

  You can also bin S3 objects that are build on top of integer and
  double atomic vectors, as long as there is a method for
  \code{\link{restore}()}.}

\item{w}{If specified, an numeric vector (of the same length as \code{x})
giving weights. If weights are provided, the weights in each bin are
summed, rather than just counting the number of observations.}

\item{width}{(Positive real). The width of a bin. For S3 objects, the
  interpretation of width depends on the interpretation
  of the underlying numeric vector. For example, for dates, 1 = 1 day;
  for times 1 = 1 second; and for difftime, the units vary.

  If \code{NULL}, the \code{width} will be derived from the data,
  picking approximately 30 bins with nice widths. You should always override
  this value, exploring multiple widths to find the best to illustrate the
  stories in your data.}

\item{origin}{The location of the left-most bin edge. Any values smaller
than the \code{origin} will be treated as if they are missing. If
\code{NULL} will be computed from \code{center} and \code{boundary}.}

\item{boundary,center}{Set the position of the first bin by specifying
  the position of either a boundary or the center of a bin.
  For example, you can always center the bins on integers with
  \code{center = 0} regardless of where the first bin actually falls.

  Think of binning as tiling the real line into a infinite sequence of
  intervals. \code{center} and \code{boundary} set the position of
  one of those intervals.}

\item{closed}{One of \code{"right"} or \code{"left"} indicating whether the
bin interval is left-closed (i.e. [a, b)), or right-closed (i.e. (a, b]).}

\item{pad}{If \code{TRUE}, adds empty bins at either end of x. This ensures
frequency polygons touch 0 outside the range of x. Defaults to \code{FALSE}.}
}
\description{
Bin a numeric vector and count how many observations fall in each bin.
Supports weights so that you can re-bin pre-binned data.
}
\section{Floating point}{

If a point is less than \code{binwidth} / 10^8 from the boundary between
two bins, it is shifted to fall in the bin with the closest "closed" side.
}
\examples{
x <- runif(1e6)
compute_bin_vec(x)
compute_bin_vec(x, width = 0.25)

# Bin other types of object
compute_bin_vec(Sys.time() + runif(10) * 60, 15)
compute_bin_vec(Sys.Date() + sample(30, 10), 7)

# Performance scales linearly with the size of x, and the number
# of bins has limited impact
x <- runif(1e7)
system.time(compute_bin_vec(x, width = 0.1))
system.time(compute_bin_vec(x, width = 1 / 100))
system.time(compute_bin_vec(x, width = 1 / 1e5))
}
\keyword{internal}

